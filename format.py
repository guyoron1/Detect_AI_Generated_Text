# To format data to competition format - including creation of prompts based on promptless ones
import os

import pandas as pd
import numpy as np

import fetch_data

DATASET_NAME_TO_PATH = {
    'daigt': './external_sources/daigt/train_v2_drcat_02.csv',
    'persuade': './external_sources/persuade/persuade_corpus_2.0_train.csv',
    'fpe': './external_sources/fpe'
}

REQUIRED_COLS = (
    'prompt_name', # Identifier for prompt in plaintext.
    'prompt_text', # Actual prompt.
    'essay', # Essay writted by student / LLM.
    'is_prompt_llm_generated', # For datasets that lack prompts - whether the prompt was generated by us in reverse.
    'generated', # Classification label - 0 by student, 1 by LLM (target)
    )
def format_dataset(dataset_name):
    """
    Given dataset identifier return df with data as formatted for competition.
    """
    path = DATASET_NAME_TO_PATH[dataset_name]
    plain_df = dataset_to_pandas(dataset_name, path)
    df_with_prompts = add_prompts(plain_df) # Fill in prompts with LLM pipeline (if needed)
    df_with_prompts_and_prompt_texts = add_prompt_names(df_with_prompts) # Fill in missing titles for prompts



def dataset_to_pandas(dataset_name, path):
    # Divide into cases by datasets.
    if dataset_name == 'daigt':
        df = format_daigt_to_df(path)
    elif dataset_name == 'persuade':
        df = format_persuade_to_df(path)
    elif dataset_name == 'fpe':
        df = format_fpe_to_df(path)

    df = df.drop_duplicates(subset='essay_text')
    return df

def format_daigt_to_df(path):
    df = pd.read_csv(path)
    df = df.rename(columns={'text':'essay_text','label':'generated'})
    df = df[df['RDizzl3_seven'] == True] # Filtering present in Daigt2.0 that says whether the essay was written in response to an original prompt from the challange.
    df = df.drop(columns=['RDizzl3_seven','source'])
    mapping = fetch_data.map_prompt_name_to_prompt_text_persuade()
    df['prompt_text'] = df['prompt_name'].map(mapping)
    return df

def format_persuade_to_df(path):
    df = pd.read_csv(path)
    df = df.rename(columns={'full_text':'essay_text','assignment':'prompt_text'})
    df = df[['prompt_name','prompt_text','essay_text']]
    df['generated'] = 0
    return df

def format_fpe_to_df(path):
    dataframes = {}
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        df_name = os.path.splitext(file)[0]  # Use the filename (without extension) as the key
        if file.endswith(".csv"):
            if df_name == 't5_essays_processed' or df_name == 'mlm_essays_processed':
                dataframes[df_name] = pd.read_csv(file_path)
        elif file.endswith(".parquet") and not(file.startswith('cv')):
            df = pd.read_parquet(file_path)
            dataframes[df_name] = df

    # Format datasets
    for name, df in dataframes.items():
        if name == 't5_essays_processed':
            df = df[['essay_text']]
            df['generated'] = 1
        elif name == 'mlm_essays_processed':
            df = df.rename(columns={'prompt':'prompt_text'})
            df = df[['essay_text', 'prompt_text']]
            df['generated'] = 1
        elif name.startswith("fpe"):
            df = df[['essay_text']]
            df['generated'] = 0
        else:
            print('a')
        dataframes[name] = df
    result = pd.concat(
        [df.assign(source=key) for key, df in dataframes.items()],
        ignore_index=True,
        sort=False  # Align columns automatically, filling missing ones with NaN
    )
    return result







def add_prompts(df: pd.DataFrame):
    #do this for all df, check whether there is NaN in any of the prompt columns (also need to fill in the prompt name, consistently..)
    fill_all = False
    if 'prompt_text' not in df.columns:
        fill_all = True
    for _, row in df.iterrows():
        if pd.isna(row['prompt_text']) or fill_all:
            fill_prompt_text_from_llm(row) # In place?
    return df

def fill_prompt_text_from_llm(row: pd.Series):
    #todo: add guy's functionality
    pass

def add_prompt_names(df: pd.DataFrame):
    unique_prompts = df['prompt_text']
    prompts_to_names_mapping = fill_prompt_name_given_prompt_text_with_llm(unique_prompts) # Dictionary.

def fill_prompt_name_given_prompt_text_with_llm(unique_prompts: np.ndarray):
    return dict()

if __name__ == '__main__':
    df = format_dataset('fpe')